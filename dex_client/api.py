# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: api.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib


@dataclass
class Client(betterproto.Message):
    """Client represents an OAuth2 client."""

    id: str = betterproto.string_field(1)
    secret: str = betterproto.string_field(2)
    redirect_uris: List[str] = betterproto.string_field(3)
    trusted_peers: List[str] = betterproto.string_field(4)
    public: bool = betterproto.bool_field(5)
    name: str = betterproto.string_field(6)
    logo_url: str = betterproto.string_field(7)


@dataclass
class GetClientReq(betterproto.Message):
    """GetClientReq is a request to retrieve client details."""

    # The ID of the client.
    id: str = betterproto.string_field(1)


@dataclass
class GetClientResp(betterproto.Message):
    """GetClientResp returns the client details."""

    client: "Client" = betterproto.message_field(1)


@dataclass
class CreateClientReq(betterproto.Message):
    """CreateClientReq is a request to make a client."""

    client: "Client" = betterproto.message_field(1)


@dataclass
class CreateClientResp(betterproto.Message):
    """CreateClientResp returns the response from creating a client."""

    already_exists: bool = betterproto.bool_field(1)
    client: "Client" = betterproto.message_field(2)


@dataclass
class DeleteClientReq(betterproto.Message):
    """DeleteClientReq is a request to delete a client."""

    # The ID of the client.
    id: str = betterproto.string_field(1)


@dataclass
class DeleteClientResp(betterproto.Message):
    """DeleteClientResp determines if the client is deleted successfully."""

    not_found: bool = betterproto.bool_field(1)


@dataclass
class UpdateClientReq(betterproto.Message):
    """UpdateClientReq is a request to update an existing client."""

    id: str = betterproto.string_field(1)
    redirect_uris: List[str] = betterproto.string_field(2)
    trusted_peers: List[str] = betterproto.string_field(3)
    name: str = betterproto.string_field(4)
    logo_url: str = betterproto.string_field(5)


@dataclass
class UpdateClientResp(betterproto.Message):
    """UpdateClientResp returns the response from updating a client."""

    not_found: bool = betterproto.bool_field(1)


@dataclass
class Password(betterproto.Message):
    """Password is an email for password mapping managed by the storage."""

    email: str = betterproto.string_field(1)
    # Currently we do not accept plain text passwords. Could be an option in the
    # future.
    hash: bytes = betterproto.bytes_field(2)
    username: str = betterproto.string_field(3)
    user_id: str = betterproto.string_field(4)


@dataclass
class CreatePasswordReq(betterproto.Message):
    """CreatePasswordReq is a request to make a password."""

    password: "Password" = betterproto.message_field(1)


@dataclass
class CreatePasswordResp(betterproto.Message):
    """CreatePasswordResp returns the response from creating a password."""

    already_exists: bool = betterproto.bool_field(1)


@dataclass
class UpdatePasswordReq(betterproto.Message):
    """UpdatePasswordReq is a request to modify an existing password."""

    # The email used to lookup the password. This field cannot be modified
    email: str = betterproto.string_field(1)
    new_hash: bytes = betterproto.bytes_field(2)
    new_username: str = betterproto.string_field(3)


@dataclass
class UpdatePasswordResp(betterproto.Message):
    """
    UpdatePasswordResp returns the response from modifying an existing
    password.
    """

    not_found: bool = betterproto.bool_field(1)


@dataclass
class DeletePasswordReq(betterproto.Message):
    """DeletePasswordReq is a request to delete a password."""

    email: str = betterproto.string_field(1)


@dataclass
class DeletePasswordResp(betterproto.Message):
    """DeletePasswordResp returns the response from deleting a password."""

    not_found: bool = betterproto.bool_field(1)


@dataclass
class ListPasswordReq(betterproto.Message):
    """ListPasswordReq is a request to enumerate passwords."""

    pass


@dataclass
class ListPasswordResp(betterproto.Message):
    """ListPasswordResp returns a list of passwords."""

    passwords: List["Password"] = betterproto.message_field(1)


@dataclass
class Connector(betterproto.Message):
    """
    Connector is a strategy used by Dex for authenticating a user against
    another identity provider
    """

    id: str = betterproto.string_field(1)
    type: str = betterproto.string_field(2)
    name: str = betterproto.string_field(3)
    config: bytes = betterproto.bytes_field(4)


@dataclass
class CreateConnectorReq(betterproto.Message):
    """CreateConnectorReq is a request to make a connector."""

    connector: "Connector" = betterproto.message_field(1)


@dataclass
class CreateConnectorResp(betterproto.Message):
    """CreateConnectorResp returns the response from creating a connector."""

    already_exists: bool = betterproto.bool_field(1)


@dataclass
class UpdateConnectorReq(betterproto.Message):
    """UpdateConnectorReq is a request to modify an existing connector."""

    # The id used to lookup the connector. This field cannot be modified
    id: str = betterproto.string_field(1)
    new_type: str = betterproto.string_field(2)
    new_name: str = betterproto.string_field(3)
    new_config: bytes = betterproto.bytes_field(4)


@dataclass
class UpdateConnectorResp(betterproto.Message):
    """
    UpdateConnectorResp returns the response from modifying an existing
    connector.
    """

    not_found: bool = betterproto.bool_field(1)


@dataclass
class DeleteConnectorReq(betterproto.Message):
    """DeleteConnectorReq is a request to delete a connector."""

    id: str = betterproto.string_field(1)


@dataclass
class DeleteConnectorResp(betterproto.Message):
    """DeleteConnectorResp returns the response from deleting a connector."""

    not_found: bool = betterproto.bool_field(1)


@dataclass
class ListConnectorReq(betterproto.Message):
    """ListConnectorReq is a request to enumerate connectors."""

    pass


@dataclass
class ListConnectorResp(betterproto.Message):
    """ListConnectorResp returns a list of connectors."""

    connectors: List["Connector"] = betterproto.message_field(1)


@dataclass
class VersionReq(betterproto.Message):
    """VersionReq is a request to fetch version info."""

    pass


@dataclass
class VersionResp(betterproto.Message):
    """VersionResp holds the version info of components."""

    # Semantic version of the server.
    server: str = betterproto.string_field(1)
    # Numeric version of the API. It increases every time a new call is added to
    # the API. Clients should use this info to determine if the server supports
    # specific features.
    api: int = betterproto.int32_field(2)


@dataclass
class DiscoveryReq(betterproto.Message):
    """DiscoveryReq is a request to fetch discover information."""

    pass


@dataclass
class DiscoveryResp(betterproto.Message):
    """DiscoverResp holds the version oidc disovery info."""

    issuer: str = betterproto.string_field(1)
    authorization_endpoint: str = betterproto.string_field(2)
    token_endpoint: str = betterproto.string_field(3)
    jwks_uri: str = betterproto.string_field(4)
    userinfo_endpoint: str = betterproto.string_field(5)
    device_authorization_endpoint: str = betterproto.string_field(6)
    introspection_endpoint: str = betterproto.string_field(7)
    grant_types_supported: List[str] = betterproto.string_field(8)
    response_types_supported: List[str] = betterproto.string_field(9)
    subject_types_supported: List[str] = betterproto.string_field(10)
    id_token_signing_alg_values_supported: List[str] = betterproto.string_field(11)
    code_challenge_methods_supported: List[str] = betterproto.string_field(12)
    scopes_supported: List[str] = betterproto.string_field(13)
    token_endpoint_auth_methods_supported: List[str] = betterproto.string_field(14)
    claims_supported: List[str] = betterproto.string_field(15)


@dataclass
class RefreshTokenRef(betterproto.Message):
    """
    RefreshTokenRef contains the metadata for a refresh token that is managed
    by the storage.
    """

    # ID of the refresh token.
    id: str = betterproto.string_field(1)
    client_id: str = betterproto.string_field(2)
    created_at: int = betterproto.int64_field(5)
    last_used: int = betterproto.int64_field(6)


@dataclass
class ListRefreshReq(betterproto.Message):
    """
    ListRefreshReq is a request to enumerate the refresh tokens of a user.
    """

    # The "sub" claim returned in the ID Token.
    user_id: str = betterproto.string_field(1)


@dataclass
class ListRefreshResp(betterproto.Message):
    """ListRefreshResp returns a list of refresh tokens for a user."""

    refresh_tokens: List["RefreshTokenRef"] = betterproto.message_field(1)


@dataclass
class RevokeRefreshReq(betterproto.Message):
    """
    RevokeRefreshReq is a request to revoke the refresh token of the user-
    client pair.
    """

    # The "sub" claim returned in the ID Token.
    user_id: str = betterproto.string_field(1)
    client_id: str = betterproto.string_field(2)


@dataclass
class RevokeRefreshResp(betterproto.Message):
    """
    RevokeRefreshResp determines if the refresh token is revoked successfully.
    """

    # Set to true is refresh token was not found and token could not be revoked.
    not_found: bool = betterproto.bool_field(1)


@dataclass
class VerifyPasswordReq(betterproto.Message):
    email: str = betterproto.string_field(1)
    password: str = betterproto.string_field(2)


@dataclass
class VerifyPasswordResp(betterproto.Message):
    verified: bool = betterproto.bool_field(1)
    not_found: bool = betterproto.bool_field(2)


class DexStub(betterproto.ServiceStub):
    """Dex represents the dex gRPC service."""

    async def get_client(self, *, id: str = "") -> GetClientResp:
        """GetClient gets a client."""

        request = GetClientReq()
        request.id = id

        return await self._unary_unary(
            "/api.Dex/GetClient",
            request,
            GetClientResp,
        )

    async def create_client(
        self, *, client: Optional["Client"] = None
    ) -> CreateClientResp:
        """CreateClient creates a client."""

        request = CreateClientReq()
        if client is not None:
            request.client = client

        return await self._unary_unary(
            "/api.Dex/CreateClient",
            request,
            CreateClientResp,
        )

    async def update_client(
        self,
        *,
        id: str = "",
        redirect_uris: List[str] = [],
        trusted_peers: List[str] = [],
        name: str = "",
        logo_url: str = "",
    ) -> UpdateClientResp:
        """UpdateClient updates an existing client"""

        request = UpdateClientReq()
        request.id = id
        request.redirect_uris = redirect_uris
        request.trusted_peers = trusted_peers
        request.name = name
        request.logo_url = logo_url

        return await self._unary_unary(
            "/api.Dex/UpdateClient",
            request,
            UpdateClientResp,
        )

    async def delete_client(self, *, id: str = "") -> DeleteClientResp:
        """DeleteClient deletes the provided client."""

        request = DeleteClientReq()
        request.id = id

        return await self._unary_unary(
            "/api.Dex/DeleteClient",
            request,
            DeleteClientResp,
        )

    async def create_password(
        self, *, password: Optional["Password"] = None
    ) -> CreatePasswordResp:
        """CreatePassword creates a password."""

        request = CreatePasswordReq()
        if password is not None:
            request.password = password

        return await self._unary_unary(
            "/api.Dex/CreatePassword",
            request,
            CreatePasswordResp,
        )

    async def update_password(
        self, *, email: str = "", new_hash: bytes = b"", new_username: str = ""
    ) -> UpdatePasswordResp:
        """UpdatePassword modifies existing password."""

        request = UpdatePasswordReq()
        request.email = email
        request.new_hash = new_hash
        request.new_username = new_username

        return await self._unary_unary(
            "/api.Dex/UpdatePassword",
            request,
            UpdatePasswordResp,
        )

    async def delete_password(self, *, email: str = "") -> DeletePasswordResp:
        """DeletePassword deletes the password."""

        request = DeletePasswordReq()
        request.email = email

        return await self._unary_unary(
            "/api.Dex/DeletePassword",
            request,
            DeletePasswordResp,
        )

    async def list_passwords(self) -> ListPasswordResp:
        """ListPassword lists all password entries."""

        request = ListPasswordReq()

        return await self._unary_unary(
            "/api.Dex/ListPasswords",
            request,
            ListPasswordResp,
        )

    async def create_connector(
        self, *, connector: Optional["Connector"] = None
    ) -> CreateConnectorResp:
        """CreateConnector creates a connector."""

        request = CreateConnectorReq()
        if connector is not None:
            request.connector = connector

        return await self._unary_unary(
            "/api.Dex/CreateConnector",
            request,
            CreateConnectorResp,
        )

    async def update_connector(
        self,
        *,
        id: str = "",
        new_type: str = "",
        new_name: str = "",
        new_config: bytes = b"",
    ) -> UpdateConnectorResp:
        """UpdateConnector modifies existing connector."""

        request = UpdateConnectorReq()
        request.id = id
        request.new_type = new_type
        request.new_name = new_name
        request.new_config = new_config

        return await self._unary_unary(
            "/api.Dex/UpdateConnector",
            request,
            UpdateConnectorResp,
        )

    async def delete_connector(self, *, id: str = "") -> DeleteConnectorResp:
        """DeleteConnector deletes the connector."""

        request = DeleteConnectorReq()
        request.id = id

        return await self._unary_unary(
            "/api.Dex/DeleteConnector",
            request,
            DeleteConnectorResp,
        )

    async def list_connectors(self) -> ListConnectorResp:
        """ListConnectors lists all connector entries."""

        request = ListConnectorReq()

        return await self._unary_unary(
            "/api.Dex/ListConnectors",
            request,
            ListConnectorResp,
        )

    async def get_version(self) -> VersionResp:
        """GetVersion returns version information of the server."""

        request = VersionReq()

        return await self._unary_unary(
            "/api.Dex/GetVersion",
            request,
            VersionResp,
        )

    async def get_discovery(self) -> DiscoveryResp:
        """GetDiscovery returns discovery information of the server."""

        request = DiscoveryReq()

        return await self._unary_unary(
            "/api.Dex/GetDiscovery",
            request,
            DiscoveryResp,
        )

    async def list_refresh(self, *, user_id: str = "") -> ListRefreshResp:
        """
        ListRefresh lists all the refresh token entries for a particular user.
        """

        request = ListRefreshReq()
        request.user_id = user_id

        return await self._unary_unary(
            "/api.Dex/ListRefresh",
            request,
            ListRefreshResp,
        )

    async def revoke_refresh(
        self, *, user_id: str = "", client_id: str = ""
    ) -> RevokeRefreshResp:
        """
        RevokeRefresh revokes the refresh token for the provided user-client
        pair. Note that each user-client pair can have only one refresh token
        at a time.
        """

        request = RevokeRefreshReq()
        request.user_id = user_id
        request.client_id = client_id

        return await self._unary_unary(
            "/api.Dex/RevokeRefresh",
            request,
            RevokeRefreshResp,
        )

    async def verify_password(
        self, *, email: str = "", password: str = ""
    ) -> VerifyPasswordResp:
        """
        VerifyPassword returns whether a password matches a hash for a specific
        email or not.
        """

        request = VerifyPasswordReq()
        request.email = email
        request.password = password

        return await self._unary_unary(
            "/api.Dex/VerifyPassword",
            request,
            VerifyPasswordResp,
        )
